package processors;

import org.apache.spark.sql.*;
import org.apache.spark.sql.expressions.Window;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.Metadata;
import org.apache.spark.sql.types.StructField;
import org.apache.spark.sql.types.StructType;
import proto.RecordProto;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class RecordProcessor {

    private SparkSession spark;

    public RecordProcessor() {
        this.spark = SparkSession.builder()
                .appName("Example")
                .master("local")
                .getOrCreate();
    }

    public List<RecordProto.RecordInfo> processRecords(Dataset<Row> records, String userAgent, String type) {
        var selected = records.select("device_settings", "date_time", "creation_time_local");

        RecordProcessor recordProcessor = new RecordProcessor();

        var counts = recordProcessor.countRecordsByHour(selected);
        var averages = recordProcessor.averageBetweenSubsequentRecords(selected);

        var combined = counts.join(averages, "date_time", "full").na().fill(0);

        combined.show(false);

        List<RecordProto.RecordInfo> results = new ArrayList<>();
        for (var row : combined.collectAsList()) {
            String dateTime = row.getString(0);
            String date = dateTime.substring(0, 8);
            int hour = Integer.parseInt(dateTime.substring(8));
            String interval = String.format("%s %d:00 - %s %d:00", date, hour, date, hour + 1);

            RecordProto.RecordInfo info = RecordProto.RecordInfo.newBuilder()
                    .setUserAgent(userAgent)
                    .setType(type)
                    .setTimeInterval(interval)
                    .setRecordCount(row.getLong(1))
                    .setAverageBetweenRecords(row.getDouble(2))
                    .build();
            results.add(info);
        }
        return results;
    }

    private Dataset<Row> countRecordsByHour(Dataset<Row> records) {
        var minMax = records.agg(functions.min("date_time"), functions.max("date_time")).collectAsList().get(0);
        String startTime = minMax.getString(0);
        String endTime = minMax.getString(1);

        var times = allTimes(startTime, endTime);

        StructType schema = new StructType(new StructField[]{
                new StructField("date_time", DataTypes.StringType, false, Metadata.empty())
        });
        var timeDF = spark.createDataFrame(times.stream().map(RowFactory::create).collect(Collectors.toList()), schema);

        var grouped = records.groupBy("date_time").count();

        var joined = timeDF.join(grouped, "date_time", "left").na().fill(0);
        joined.show(false);

        return joined;
    }

    private Dataset<Row> averageBetweenSubsequentRecords(Dataset<Row> records) {
        // Create "diff" column that is generated by difference of creation_time of two subsequent rows
        var recordsWithDiff = records.withColumn("diff", records.col("creation_time_local").minus(functions.lag("creation_time_local", 1).over(Window.partitionBy("date_time").orderBy("creation_time_local"))));

        // Drop rows with "diff" as null, because they are first records of the date and hour.
        recordsWithDiff = recordsWithDiff.na().drop(new String[]{ "diff" });

        // Group by date and hour and calculate average
        var grouped = recordsWithDiff.groupBy("date_time").avg("diff");
        grouped.show(false);

        return grouped;
    }

    private List<String> allTimes(String start, String end) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHH");
        LocalDateTime startTime = LocalDateTime.parse(start, formatter);
        LocalDateTime endTime = LocalDateTime.parse(end, formatter);

        List<LocalDateTime> times = new ArrayList<>();
        times.add(startTime);

        while (!startTime.equals(endTime)) {
            startTime = startTime.plusHours(1);
            times.add(startTime);
        }

        return times.stream().map(time -> time.format(formatter)).collect(Collectors.toList());
    }
}
